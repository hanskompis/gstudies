(function (a) { var c = { series: { curvedLines: { active: false, show: false, fit: true, lineWidth: 1, curvePointFactor: 30, fitPointDist: 0, fill: false, fillColor: null}} }; function b(g) { var j = g.getOptions(); var f = j.xaxis.mode == "time"; g.hooks.processOptions.push(k); function k(m, l) { if (l.series.curvedLines.active) { m.hooks.draw.push(e) } } function e(q, n) { var t; var l = q.getAxes(); var s = q.getData(); var p = q.getPlotOffset(); for (var o = 0; o < s.length; o++) { t = s[o]; if (t.curvedLines.show && t.curvedLines.lineWidth > 0) { axisx = t.xaxis; axisy = t.yaxis; n.save(); n.translate(p.left, p.top); n.lineJoin = "round"; n.strokeStyle = t.color; n.lineWidth = t.curvedLines.lineWidth; var r = d(t.data, t.curvedLines); t.datapoints.points = r; h(n, t.datapoints.points, axisx, axisy); if ((typeof t.curvedLines.fill == "number" && t.curvedLines.fill == 1) || (t.curvedLines.fill == true)) { var m = t.curvedLines.fillColor ? a.color.parse(t.curvedLines.fillColor) : a.color.parse(t.color); if (typeof t.curvedLines.fill == "number") { m.a = t.curvedLines.fill } else { if (!t.curvedLines.fillColor) { m.a = 0.4 } } m.normalize(); n.fillStyle = m.toString(); i(n, t.datapoints, axisx, axisy) } n.restore() } } } function h(n, p, l, m) { var s = 2; var q = null; var r = null; n.beginPath(); for (var o = s; o < p.length; o += s) { var t = p[o - s], v = p[o - s + 1]; var u = p[o], w = p[o + 1]; if (t == null || u == null) { continue } if (v <= w && v < m.min) { if (w < m.min) { continue } t = (m.min - v) / (w - v) * (u - t) + t; v = m.min } else { if (w <= v && w < m.min) { if (v < m.min) { continue } u = (m.min - v) / (w - v) * (u - t) + t; w = m.min } } if (v >= w && v > m.max) { if (w > m.max) { continue } t = (m.max - v) / (w - v) * (u - t) + t; v = m.max } else { if (w >= v && w > m.max) { if (v > m.max) { continue } u = (m.max - v) / (w - v) * (u - t) + t; w = m.max } } if (t <= u && t < l.min) { if (u < l.min) { continue } v = (l.min - t) / (u - t) * (w - v) + v; t = l.min } else { if (u <= t && u < l.min) { if (t < l.min) { continue } w = (l.min - t) / (u - t) * (w - v) + v; u = l.min } } if (t >= u && t > l.max) { if (u > l.max) { continue } v = (l.max - t) / (u - t) * (w - v) + v; t = l.max } else { if (u >= t && u > l.max) { if (t > l.max) { continue } w = (l.max - t) / (u - t) * (w - v) + v; u = l.max } } if (t != q || v != r) { n.moveTo(l.p2c(t), m.p2c(v)) } q = u; r = w; n.lineTo(l.p2c(u), m.p2c(w)) } n.stroke() } function i(p, q, m, n) { var t = q.points, u = q.pointsize, o = Math.min(Math.max(0, n.min), n.max), v, s = 0, l = false; for (var r = u; r < t.length; r += u) { var w = t[r - u], A = t[r - u + 1], y = t[r], B = t[r + 1]; if (l && w != null && y == null) { p.lineTo(m.p2c(s), n.p2c(o)); p.fill(); l = false; continue } if (w == null || y == null) { continue } if (w <= y && w < m.min) { if (y < m.min) { continue } A = (m.min - w) / (y - w) * (B - A) + A; w = m.min } else { if (y <= w && y < m.min) { if (w < m.min) { continue } B = (m.min - w) / (y - w) * (B - A) + A; y = m.min } } if (w >= y && w > m.max) { if (y > m.max) { continue } A = (m.max - w) / (y - w) * (B - A) + A; w = m.max } else { if (y >= w && y > m.max) { if (w > m.max) { continue } B = (m.max - w) / (y - w) * (B - A) + A; y = m.max } } if (!l) { p.beginPath(); p.moveTo(m.p2c(w), n.p2c(o)); l = true } if (A >= n.max && B >= n.max) { p.lineTo(m.p2c(w), n.p2c(n.max)); p.lineTo(m.p2c(y), n.p2c(n.max)); s = y; continue } else { if (A <= n.min && B <= n.min) { p.lineTo(m.p2c(w), n.p2c(n.min)); p.lineTo(m.p2c(y), n.p2c(n.min)); s = y; continue } } var x = w, z = y; if (A <= B && A < n.min && B >= n.min) { w = (n.min - A) / (B - A) * (y - w) + w; A = n.min } else { if (B <= A && B < n.min && A >= n.min) { y = (n.min - A) / (B - A) * (y - w) + w; B = n.min } } if (A >= B && A > n.max && B <= n.max) { w = (n.max - A) / (B - A) * (y - w) + w; A = n.max } else { if (B >= A && B > n.max && A <= n.max) { y = (n.max - A) / (B - A) * (y - w) + w; B = n.max } } if (w != x) { if (A <= n.min) { v = n.min } else { v = n.max } p.lineTo(m.p2c(x), n.p2c(v)); p.lineTo(m.p2c(w), n.p2c(v)) } p.lineTo(m.p2c(w), n.p2c(A)); p.lineTo(m.p2c(y), n.p2c(B)); if (y != z) { if (B <= n.min) { v = n.min } else { v = n.max } p.lineTo(m.p2c(y), n.p2c(v)); p.lineTo(m.p2c(z), n.p2c(v)) } s = Math.max(y, z) } if (l) { p.lineTo(m.p2c(s), n.p2c(o)); p.fill() } } function d(r, o) { var D = o.curvePointFactor * r.length; var I = new Array; var L = new Array; if (o.fit) { var C = o.fitPointDist; var x = 0; for (var w = 0; w < r.length; w++) { if (f) { var u = new Date(r[w][0]); u.setMinutes(u.getMinutes() - 1); I[x] = u.getTime() } else { I[x] = r[w][0] - 0.01 } if (w > 0) { L[x] = r[w - 1][1] * C + r[w][1] * (1 - C) } else { L[x] = r[w][1] } x++; I[x] = r[w][0]; L[x] = r[w][1]; x++; if (f) { var u = new Date(r[w][0]); u.setMinutes(u.getMinutes() + 1); I[x] = u.getTime() } else { I[x] = r[w][0] + 0.01 } if ((w + 1) < r.length) { L[x] = r[w + 1][1] * C + r[w][1] * (1 - C) } else { L[x] = r[w][1] } x++ } } else { for (var w = 0; w < r.length; w++) { I[w] = r[w][0]; L[w] = r[w][1] } } var B = I.length; var K = new Array(); var t = new Array(); K[0] = 0; K[B - 1] = 0; t[0] = 0; for (var w = 1; w < B - 1; ++w) { var q = (I[w + 1] - I[w - 1]); if (q == 0) { return null } var G = (I[w] - I[w - 1]) / q; var E = G * K[w - 1] + 2; K[w] = (G - 1) / E; t[w] = (L[w + 1] - L[w]) / (I[w + 1] - I[w]) - (L[w] - L[w - 1]) / (I[w] - I[w - 1]); t[w] = (6 * t[w] / (I[w + 1] - I[w - 1]) - G * t[w - 1]) / E } for (var x = B - 2; x >= 0; --x) { K[x] = K[x] * K[x + 1] + t[x] } var H = (I[B - 1] - I[0]) / (D - 1); var J = new Array; var M = new Array; var F = new Array; J[0] = I[0]; M[0] = L[0]; for (x = 1; x < D; ++x) { J[x] = J[0] + x * H; var z = B - 1; var A = 0; while (z - A > 1) { var y = Math.round((z + A) / 2); if (I[y] > J[x]) { z = y } else { A = y } } var v = (I[z] - I[A]); if (v == 0) { return null } var l = (I[z] - J[x]) / v; var m = (J[x] - I[A]) / v; M[x] = l * L[A] + m * L[z] + ((l * l * l - l) * K[A] + (m * m * m - m) * K[z]) * (v * v) / 6; F.push(J[x]); F.push(M[x]) } return F } } a.plot.plugins.push({ init: b, options: c, name: "curvedLines", version: "0.2.3" }) })(jQuery);